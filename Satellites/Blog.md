Part 1:
To start off with I knew that I had to take a lot of notes on the spec in order to kow what I needed to design to make a basic skeleton of the program. The spec told us that there would be three different types of Devices and Satellites we had to make classes for. The connection between the two however were that both devices and satellites needed a position, range, Id, and type attribute, along with the approprite getters and setters. Thus I also made an Entity superclass that the device and satellite superclass would extend.
Each of the three final subclasses for both the Device and Satellite class were then attributed with their base values given in the spec. I knew I would eventually need to make a move method for each of the satellites, so I gave the Satellite superclass the move method that would be overriden in the case of the relay and teleporting satellites.
I began to fill out the basic create, remove, and get functions from part 1. From the spec and creaetDevice prototype, I know that each device final subclass would need a constructor with the deviceId, type, and position as parameters. However, I also realised that I needed somewhere for the new devices and eventually satellites to be stored. So I had the blackout controller keep a List of Device and Satellite objects as attributes. This way, when deleting the objects, I would just remove the object from the controller's corresponding list of objects.
The rest of part 1's implementation was straight forward, the addFileToDevice function caused me to add an attribute of a list of File objects that corresponded to the given FileInfoResponse class we were given. There the File class was made.
The get Entity information method had me think to add a list of entities to the blackout controller object that way I would only need to scan through oe list in order to get the right entity and its information to retun in the entityInfoReponse format.
Part 2:
Running the simulation. I thought I was going to be well prepared for this part as I already had a move prototype in the Satellite superclass. Here I implemented the basic movement into the superclass and thus all of the satellites inherited it. However, the two different satellite types needed overrides. The overrides consisted of the same superclass move method, only there were specific conditions that both of them needed for correcting and teleporting.
Listing all of the entities in range of a given entity was rough. After reading the spec for it I realised that there was a possibility where I would need to run it recursively. The way a relay works is essentially like a signal amplifier where if there is a relay in range then it would add all of the entities within it's range to the list of communicable entities. To be sure of an entities distance and visibility to the source entity I used the given mathsHelper methods to make sure that an entity from the entities list was both within range of the source and was visible and then added it's id to the list of Strings I returned. At the end I made sure to get rid of any deviceIds using the method from part1 in the case that the source entity was a device itself
File transferring has successfully flippled everything I thought I had on it's head. First things first is the error checking. I saw the heirarchy of exceptions to throw on the bottom of the spec and went in that order. First was to make sure that the file existed on the source's list of current files. This also got me thinking that the satellite supperclass should probably have an attribute of a list of file objects of all of the files that the satellite has completely downloaded ready to be uploaded. This would be alongside a seperate file list of all of the files that were in the process of being downloaded.
After implementeing the file lists and their logic, it downed on me that even though, devices had unlimited upload and download, satellites don't. So there would need to be a different list of Files that would mark the files that were in the process of being downloaded limited by the satellites outward bandwidth. The same went for uploading files. The way I was going to transfer files was going to be character by character. This way I would just pop the first character from the source File and append it onto the destintion file by however much bandwidth was available per tick. Then there is the case of the standard satellite where the partially downloaded file is given back to the source by adding the last bit of the partial trasnfer to the beginnig of the source file repeatadly until the destination File is empty.
It just occured to me that relay satellites shouldn't have any of these lists of files that were attributes on the entity superclass. It's unnecessary information. There were also the helper methods I was writing in the entity superclass that just were not in any way applicable to relay satellites. The way I decided to circumnavigate this was to make the Satellite abstract superclass into an interface. This way I would make another abstract superclass NormalSatellite that would take the place of Satellite for the standard and teleporting satellites to inherit. Here I kept the standard move implementation I had before that teleport still overrode. Relay's move method was different to the basic move behavior anyway so implementing that under the satellite interface (that NormalSatellite superclass also implements) was not really repetative.
After this rework I thought to myself that Relay still needs to extend an abstract superclass. But when I went to extend Entity I realized that there was a heap of extra data that it didn't need form Entity. This is where I refactored Entity into Entity and ExchangingEntity that extended Entity which was holding everything that Relay Satellite needed without anything more (position, type, Id...). Then I had Normal Satellite and Device extend ExchangingEntity, because those are the final subclasses that actually exchange files.
While reworking the send file logic into the System there were a lot of helper funnctins that the exchanging entities needed in order to operate accordingly. There were a lot of edge cases where a file trnasfer would be interupted for one reason or another. Thus there needed to be helper functions in teleporting satellite subclass and the exchanging entity superclass where the files mid transfer would need to be found, instantly sent, instantly reverted, or any of the above without any 't' characters in the file body. There was also the problem of needing to find out which entities needed to be ticked and cancelled after each movement. This is where I decided to have the exchanging entities have a list of Strings that dictated the id's of the visible entites to the entity in question before the last movement. This is how I was able to access the visible entities of each entity before and after each movemet at the same time.